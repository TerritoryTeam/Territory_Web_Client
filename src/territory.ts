// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "territory.proto" (package "api", syntax proto3)
// tslint:disable
//
// Copyright 2024 The Territory Author
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message api.UserJoinLeaveMessage
 */
export interface UserJoinLeaveMessage {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string user_name = 2;
     */
    userName: string;
    /**
     * @generated from protobuf field: api.JoinType join_type = 3;
     */
    joinType: JoinType;
}
/**
 * @generated from protobuf message api.User
 */
export interface User {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string user_name = 2;
     */
    userName: string;
    /**
     * @generated from protobuf field: string user_avatar = 3;
     */
    userAvatar: string;
}
/**
 * @generated from protobuf message api.Room
 */
export interface Room {
    /**
     * @generated from protobuf field: int32 room_x = 1;
     */
    roomX: number;
    /**
     * @generated from protobuf field: int32 room_y = 2;
     */
    roomY: number;
    /**
     * @generated from protobuf field: optional api.User userOwner = 3;
     */
    userOwner?: User;
}
/**
 * @generated from protobuf message api.ListAvailableRoomMessage
 */
export interface ListAvailableRoomMessage {
    /**
     * @generated from protobuf field: string world_id = 1;
     */
    worldId: string;
    /**
     * @generated from protobuf field: int32 room_total = 2;
     */
    roomTotal: number;
    /**
     * @generated from protobuf field: repeated api.Room rooms = 3;
     */
    rooms: Room[];
}
/**
 * The complete set of opcodes used for communication between clients and server.
 *
 * @generated from protobuf enum api.OpCode
 */
export enum OpCode {
    /**
     * No operation specified. This is the default value.
     *
     * @generated from protobuf enum value: OPCODE_UNSPECIFIED = 0;
     */
    OPCODE_UNSPECIFIED = 0,
    /**
     * Message Event: A user has joined the server.
     *
     * @generated from protobuf enum value: OPCODE_USER_JOIN = 1;
     */
    OPCODE_USER_JOIN = 1,
    /**
     * Message Event: A user has left the server.
     *
     * @generated from protobuf enum value: OPCODE_USER_LEAVE = 2;
     */
    OPCODE_USER_LEAVE = 2,
    /**
     * Message Event: A Room has been updated.
     *
     * @generated from protobuf enum value: OPCODE_ROOM_UPDATE = 3;
     */
    OPCODE_ROOM_UPDATE = 3,
    /**
     * Message Event: Available Room List
     *
     * @generated from protobuf enum value: OPCODE_ROOMS_LIST_AVAILABLE = 4;
     */
    OPCODE_ROOMS_LIST_AVAILABLE = 4,
    /**
     * Client Operation: A user request to take over a room.
     *
     * @generated from protobuf enum value: OPCODE_ROOMS_TAKE_OVER = 5;
     */
    OPCODE_ROOMS_TAKE_OVER = 5,
    /**
     * A user request to be reject
     *
     * @generated from protobuf enum value: OPCODE_USER_REJECT = 6;
     */
    OPCODE_USER_REJECT = 6
}
/**
 * @generated from protobuf enum api.JoinType
 */
export enum JoinType {
    /**
     * No join type specified. This is the default value.
     *
     * @generated from protobuf enum value: JOIN_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * A new user has joined the server.
     *
     * @generated from protobuf enum value: JOIN_TYPE_NEW_USER_JOIN = 1;
     */
    NEW_USER_JOIN = 1,
    /**
     * A user has rejoined the server.
     *
     * @generated from protobuf enum value: JOIN_TYPE_USER_REJOIN = 2;
     */
    USER_REJOIN = 2,
    /**
     * A user has left the server.
     *
     * @generated from protobuf enum value: JOIN_TYPE_USER_LEAVE = 3;
     */
    USER_LEAVE = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class UserJoinLeaveMessage$Type extends MessageType<UserJoinLeaveMessage> {
    constructor() {
        super("api.UserJoinLeaveMessage", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "join_type", kind: "enum", T: () => ["api.JoinType", JoinType, "JOIN_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<UserJoinLeaveMessage>): UserJoinLeaveMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.userName = "";
        message.joinType = 0;
        if (value !== undefined)
            reflectionMergePartial<UserJoinLeaveMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserJoinLeaveMessage): UserJoinLeaveMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string user_name */ 2:
                    message.userName = reader.string();
                    break;
                case /* api.JoinType join_type */ 3:
                    message.joinType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserJoinLeaveMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string user_name = 2; */
        if (message.userName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userName);
        /* api.JoinType join_type = 3; */
        if (message.joinType !== 0)
            writer.tag(3, WireType.Varint).int32(message.joinType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message api.UserJoinLeaveMessage
 */
export const UserJoinLeaveMessage = new UserJoinLeaveMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("api.User", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_avatar", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.userName = "";
        message.userAvatar = "";
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string user_name */ 2:
                    message.userName = reader.string();
                    break;
                case /* string user_avatar */ 3:
                    message.userAvatar = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string user_name = 2; */
        if (message.userName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userName);
        /* string user_avatar = 3; */
        if (message.userAvatar !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userAvatar);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message api.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Room$Type extends MessageType<Room> {
    constructor() {
        super("api.Room", [
            { no: 1, name: "room_x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "room_y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "userOwner", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<Room>): Room {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roomX = 0;
        message.roomY = 0;
        if (value !== undefined)
            reflectionMergePartial<Room>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Room): Room {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 room_x */ 1:
                    message.roomX = reader.int32();
                    break;
                case /* int32 room_y */ 2:
                    message.roomY = reader.int32();
                    break;
                case /* optional api.User userOwner */ 3:
                    message.userOwner = User.internalBinaryRead(reader, reader.uint32(), options, message.userOwner);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Room, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 room_x = 1; */
        if (message.roomX !== 0)
            writer.tag(1, WireType.Varint).int32(message.roomX);
        /* int32 room_y = 2; */
        if (message.roomY !== 0)
            writer.tag(2, WireType.Varint).int32(message.roomY);
        /* optional api.User userOwner = 3; */
        if (message.userOwner)
            User.internalBinaryWrite(message.userOwner, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message api.Room
 */
export const Room = new Room$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAvailableRoomMessage$Type extends MessageType<ListAvailableRoomMessage> {
    constructor() {
        super("api.ListAvailableRoomMessage", [
            { no: 1, name: "world_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "room_total", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "rooms", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Room }
        ]);
    }
    create(value?: PartialMessage<ListAvailableRoomMessage>): ListAvailableRoomMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.worldId = "";
        message.roomTotal = 0;
        message.rooms = [];
        if (value !== undefined)
            reflectionMergePartial<ListAvailableRoomMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAvailableRoomMessage): ListAvailableRoomMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string world_id */ 1:
                    message.worldId = reader.string();
                    break;
                case /* int32 room_total */ 2:
                    message.roomTotal = reader.int32();
                    break;
                case /* repeated api.Room rooms */ 3:
                    message.rooms.push(Room.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAvailableRoomMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string world_id = 1; */
        if (message.worldId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.worldId);
        /* int32 room_total = 2; */
        if (message.roomTotal !== 0)
            writer.tag(2, WireType.Varint).int32(message.roomTotal);
        /* repeated api.Room rooms = 3; */
        for (let i = 0; i < message.rooms.length; i++)
            Room.internalBinaryWrite(message.rooms[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message api.ListAvailableRoomMessage
 */
export const ListAvailableRoomMessage = new ListAvailableRoomMessage$Type();
